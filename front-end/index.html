<html>
<body></body>
<head>
    <script src = "https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script src = "https://cdn.jsdelivr.net/npm/jquery-validation@1.17.0/dist/jquery.validate.min.js"></script>
    <script src = "https://d3js.org/d3.v4.min.js"></script>

    <script>
        var tileW, tileH;
        var viewportX, viewportY, predicate, curCanvasId, curCanvas, curJump;
        var viewportWidth, viewportHeight;
        var svg;
        var jumpOptions = d3.select("body").append("div")
            .style("margin-bottom", "40px")
            .style("text-align", "center");


        if (typeof String.prototype.parseFunction != 'function') {
            String.prototype.parseFunction = function () {
                var funcReg = /function *[^()]*\(([^()]*)\)[ \n\t]*\{(.*)\}/gmi;
                var match = funcReg.exec(this.replace(/\n/g, ' '));
                if(match)
                    return new Function(match[1].split(','), match[2]);
                else
                    return null;
            };
        }

        // get information about the first canvas to render
        function pageOnLoad() {

            // send the first request to backend server
            $.post("/first/", {}, function (data, status) {
                response = JSON.parse(data);
                console.log(response);
                viewportX = response.initialViewportX;
                viewportY = response.initialViewportY;
                predicate = response.initialPredicate;
                viewportWidth = response.viewportWidth;
                viewportHeight = response.viewportHeight;
                curCanvasId = response.initialCanvasId;
                tileW = response.tileW;
                tileH = response.tileH;
                svg = d3.select("body").append("svg")
                    .attr("width", viewportWidth)
                    .attr("height", viewportHeight);
                renderSVG();
            });
        };

        $(document).ready(pageOnLoad);

        function renderSVG() {

            // clear base svg and the jump options
            svg.node().innerHTML = '';
            jumpOptions.node().innerHTML = '';

            // get the current canvas and rendering function
            getCurCanvas();
            console.log(curCanvas);
            var renderFunc = curCanvas.rendering.parseFunction();

            // process tiles
            var margin = 0;
            var svgs = new Array(Math.floor(viewportWidth / tileW + (viewportWidth % tileW > 0 ? 1 : 0)));
            for (var i = 0; i < svgs.length; i ++)
                svgs[i] = new Array(Math.floor(viewportHeight / tileH + (viewportHeight % tileH > 0 ? 1 : 0)));
            for (var x = viewportX; x < viewportX + viewportWidth; x += tileW)
                for (var y = viewportY; y < viewportY + viewportHeight; y += tileH) {
                    // get i, j
                    var i = (x - viewportX) / tileW;
                    var j = (y - viewportY) / tileH;

                    svgs[i][j] = svg.append("svg")
                        .attr("x", x - viewportX + x / tileW * margin)
                        .attr("y", y - viewportY + y / tileH * margin)
                        .attr("width", tileW)
                        .attr("height", tileH)
                        .attr("viewBox", x + " " + y + " " + tileW + " " + tileH);
                    svgs[i][j].append("g").append("rect")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", tileW)
                        .attr("height", tileH)
                        .style("fill", "beige");

                    // send request to backend to get render func and data
                    var postData = "id=" + curCanvasId + "&"
                        + "x=" + x + "&"
                        + "y=" + y + "&"
                        + "predicate=" + predicate;
                    $.post("/tile", postData, function (data, status) {
                        var response = JSON.parse(data);
                        var renderData = response.renderData;
                        var x = response.minx;
                        var y = response.miny;
                        var i = Math.floor((x - viewportX) / tileW);
                        var j = Math.floor((y - viewportY) / tileH);
                        renderFunc(svgs[i][j], renderData);
                        registerJumps(svgs[i][j], renderData);
                    });
                }
        }

        // get from backend the current canvas object assuming curCanvasId is already correctly set
        function getCurCanvas() {

            // TODO: client cache
            $.ajax({
                type : "POST",
                url : "canvas",
                data : curCanvasId,
                success : function (data, status) {
                    curCanvas = JSON.parse(data).canvas;
                    curJump = JSON.parse(data).jump;
                },
                async : false
            });
        }

        // register jump info for a tile
        function registerJumps(svg, data) {
            var gs = svg.selectAll("g").nodes();
            for (var i = 0; i < gs.length; i ++) {
                var shapes = gs[i].childNodes;
                for (var j = 0; j < shapes.length; j ++)

                    shapes[j].onclick = function () {

                        jumpOptions.node().innerHTML = "<div>Jump to: </div>";
                        for (var k = 0; k < curJump.length; k ++) {

                            // create a button and append it to jumpOptions
                            var button = document.createElement("input");
                            button.type = "button";
                            button.value = curJump[k].destId;
                            button.setAttribute("data-tuple", this.getAttribute("data-tuple"));
                            button.setAttribute("data-jump-id", k);
                            button.style.webkitAppearance = "none";
                            button.style.margin = "10px";
                            button.style.height = "30px";
                            button.style.width = "100px";
                            button.style.fontSize = "20px";
                            button.onclick = function () {

                                var tuple = this.getAttribute("data-tuple");
                                var jumpId = this.getAttribute("data-jump-id");
                                curCanvasId = curJump[jumpId].destId;

                                // calculate a new viewport & predicate
                                console.log(tuple);
                                console.log(curJump[jumpId].newViewport);
                                var newViewportFunc = curJump[jumpId].newViewport.parseFunction();
                                var newViewportRet = newViewportFunc(tuple.split(","));
                                console.log(newViewportRet);
                                if (newViewportRet[0] == 0) {
                                    // constant viewport, no predicate
                                    viewportX = newViewportRet[1];
                                    viewportY = newViewportRet[2];
                                    predicate = '';
                                }
                                else {
                                    // viewport is fixed at a certain tuple, predicate will be added
                                    predicate = newViewportRet[1];
                                    $.ajax({
                                        type : "POST",
                                        url : "viewport",
                                        data : "canvasId=" + curCanvasId + "&predicate=" + predicate,
                                        success : function (data, status) {
                                            var cx = JSON.parse(data).cx;
                                            var cy = JSON.parse(data).cy;
                                            viewportX = cx - viewportWidth / 2;
                                            viewportY = cy - viewportHeight / 2;
                                        },
                                        async : false
                                    });
                                }

                                renderSVG();
                            };
                            jumpOptions.node().appendChild(button);
                        }
                    }
            }
        }

    </script>

</head>
</html>
