<html>
<body></body>
<head>
    <script src = "https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script src = "https://cdn.jsdelivr.net/npm/jquery-validation@1.17.0/dist/jquery.validate.min.js"></script>
    <script src = "https://d3js.org/d3.v4.min.js"></script>

    <script>

        // setting up global variables
        var globalVar = {};

        // tile width and tile height
        globalVar.tileW = 0;
        globalVar.tileH = 0;

        // current viewport info
        globalVar.initialViewportX = 0;
        globalVar.initialViewportY = 0;
        globalVar.viewportWidth = 0;
        globalVar.viewportHeight = 0;

        // predicate of the current canvas, used to retrieve data from backend
        globalVar.predicate = "";

        // the id of the current canvas
        globalVar.curCanvasId = "";

        // current canvas & jump object;
        globalVar.curCanvas = {};
        globalVar.curJump = {};

        // the global svg
        globalVar.svg = null;

        // d3 zoom
        globalVar.zoom = d3.zoom().scaleExtent([1, 1]).on("zoom", zoomed);

        // div for jump options
        globalVar.jumpOptions = d3.select("body").append("div")
            .style("margin-bottom", "40px")
            .style("text-align", "center");


        if (typeof String.prototype.parseFunction != 'function') {
            String.prototype.parseFunction = function () {
                var funcReg = /function *[^()]*\(([^()]*)\)[ \n\t]*\{(.*)\}/gmi;
                var match = funcReg.exec(this.replace(/\n/g, ' '));
                if(match)
                    return new Function(match[1].split(','), match[2]);
                else
                    return null;
            };
        }

        // zoomed function for detecting pan and zoom actions
        function zoomed() {

            var transform = d3.event.transform;
            var viewportX = globalVar.initialViewportX - transform.x;
            var viewportY = globalVar.initialViewportY - transform.y;

/*            if (viewportX >= 0 &&
                viewportY >= 0 &&
                viewportX + globalVar.viewportWidth < globalVar.curCanvas.w &&
                viewportY + globalVar.viewportHeight < globalVar.curCanvas.h) */
            RefreshCanvas(viewportX, viewportY);
        }

        // get information about the first canvas to render
        function pageOnLoad() {

            // send the first request to backend server
            $.post("/first/", {}, function (data, status) {
                var response = JSON.parse(data);
                console.log(response);
                globalVar.initialViewportX = response.initialViewportX;
                globalVar.initialViewportY = response.initialViewportY;
                globalVar.predicate = response.initialPredicate;
                globalVar.viewportWidth = response.viewportWidth;
                globalVar.viewportHeight = response.viewportHeight;
                globalVar.curCanvasId = response.initialCanvasId;
                globalVar.tileW = response.tileW;
                globalVar.tileH = response.tileH;
                globalVar.svg = d3.select("body").append("svg")
                    .attr("width", globalVar.viewportWidth)
                    .attr("height", globalVar.viewportHeight);
                globalVar.svg.call(globalVar.zoom);
                getCurCanvas();
                globalVar.jumpOptions.node().innerHTML = '';
                RefreshCanvas(globalVar.initialViewportX,
                    globalVar.initialViewportY);
            });
        };

        $(document).ready(pageOnLoad);

        // get an array of tile ids based on the current viewport location
        function getTileArray(canvasId, viewportX, viewportY, w, h) {

            var tileW = globalVar.tileW;
            var tileH = globalVar.tileH;
            // calculate the tile range that the viewport spans
            var xStart = Math.max(0, Math.floor(viewportX / tileW));
            var yStart = Math.max(0, Math.floor(viewportY / tileH));
            var xEnd = Math.min(Math.floor(w / tileW), Math.floor((viewportX + globalVar.viewportWidth) / tileW));
            var yEnd = Math.min(Math.floor(h / tileH), Math.floor((viewportY + globalVar.viewportHeight) / tileH));

            var tileIds = [];
            for (var i = xStart; i <= xEnd; i ++)
                for (var j = yStart; j <= yEnd; j ++)
                    tileIds.push([i * tileW, j * tileH, canvasId]);

            return tileIds;
        }

        // Setup a tile, 1) send a tile request; 2) call renderer; 3) register jumps
        // tileSvg is the svg corresponding to a tile
        // i and j are tile coordinates
        function renderTile(tileSvg, x, y, renderFunc, canvasId, predicate) {

            // send request to backend to get render func and data
            var postData = "id=" + canvasId + "&"
                + "x=" + x + "&"
                + "y=" + y + "&"
                + "predicate=" + predicate;
            $.post("/tile", postData, function (data, status) {
                var response = JSON.parse(data);
                var renderData = response.renderData;
                var x = response.minx;
                var y = response.miny;
                //console.log(canvasId + " " + x + " " + y + " : " + renderData);
                var tileSvg = d3.select("#a" + x + y + canvasId);
                if (tileSvg == null) // it's possible when the tile data is delayed and this tile is already removed
                    return ;
                renderFunc(tileSvg, renderData);
                registerJumps(tileSvg);
            });
        }

        function RefreshCanvas(viewportX, viewportY) {

            var tileW = globalVar.tileW;
            var tileH = globalVar.tileH;

            // get the current canvas and rendering function
            var renderFunc = globalVar.curCanvas.rendering.parseFunction();

            // get tile ids
            var tileIds = getTileArray(globalVar.curCanvasId, viewportX, viewportY,
                globalVar.curCanvas.w, globalVar.curCanvas.h);

            // render tiles
            var tiles = globalVar.svg
                .attr("viewBox", viewportX + " " + viewportY + " "
                    + globalVar.viewportWidth + " " + globalVar.viewportHeight)
                .selectAll("svg")
                .data(tileIds, function (d){return d;});
            tiles.exit().remove();
            tiles.enter().append("svg")
                .attr("width", tileW)
                .attr("height", tileH)
                .attr("id", function(d) {return "a" + d[0] + d[1] + globalVar.curCanvasId;}) //TODO: add slash-like characters
                .attr("x", function(d) {return d[0];})
                .attr("y", function(d) {return d[1];})
                .attr("viewBox", function (d) {
                    return d[0] + " " + d[1] + " " + tileW + " " + tileH;
                })
                .each(function(d) {
                    renderTile(this, d[0], d[1], renderFunc, globalVar.curCanvasId, globalVar.predicate);
                });
        }

        // get from backend the current canvas object assuming curCanvasId is already correctly set
        function getCurCanvas() {

            // TODO: client cache
            $.ajax({
                type : "POST",
                url : "canvas",
                data : globalVar.curCanvasId,
                success : function (data, status) {
                    globalVar.curCanvas = JSON.parse(data).canvas;
                    globalVar.curJump = JSON.parse(data).jump;
                },
                async : false
            });
        }

        // register jump info for a tile
        function registerJumps(svg) {
            var jumps = globalVar.curJump;
            var gs = svg.selectAll("g").nodes();
            for (var i = 0; i < gs.length; i ++) {
                var shapes = gs[i].childNodes;
                for (var j = 0; j < shapes.length; j ++)

                    shapes[j].onclick = function () {

                        globalVar.jumpOptions.node().innerHTML = "<div>Jump to: </div>";
                        for (var k = 0; k < jumps.length; k ++) {

                            // create a button and append it to jumpOptions
                            var button = document.createElement("input");
                            button.type = "button";
                            button.value = jumps[k].destId;
                            button.setAttribute("data-tuple", this.getAttribute("data-tuple"));
                            button.setAttribute("data-jump-id", k);
                            button.style.webkitAppearance = "none";
                            button.style.margin = "10px";
                            button.style.height = "30px";
                            button.style.width = "100px";
                            button.style.fontSize = "20px";
                            button.onclick = function () {

                                var tuple = this.getAttribute("data-tuple");
                                var jumpId = this.getAttribute("data-jump-id");
                                globalVar.curCanvasId = jumps[jumpId].destId;

                                // calculate a new viewport & predicate
                                var newViewportFunc = jumps[jumpId].newViewport.parseFunction();
                                var newViewportRet = newViewportFunc(tuple.split(","));
                                if (newViewportRet[0] == 0) {
                                    // constant viewport, no predicate
                                    var newViewportX = newViewportRet[1];
                                    var newViewportY = newViewportRet[2];
                                    predicate = '';
                                    getCurCanvas();
                                    RefreshCanvas(newViewportX, newViewportY);
                                }
                                else {
                                    // viewport is fixed at a certain tuple, predicate will be added
                                    globalVar.predicate = newViewportRet[1];
                                    $.ajax({
                                        type : "POST",
                                        url : "viewport",
                                        data : "canvasId=" + globalVar.curCanvasId
                                            + "&predicate=" + globalVar.predicate,
                                        success : function (data, status) {
                                            var cx = JSON.parse(data).cx;
                                            var cy = JSON.parse(data).cy;
                                            var newViewportX = cx - globalVar.viewportWidth / 2;
                                            var newViewportY = cy - globalVar.viewportHeight / 2;
                                            getCurCanvas();
                                            globalVar.jumpOptions.node().innerHTML = '';
                                            RefreshCanvas(newViewportX, newViewportY);
                                        },
                                        async : false
                                    });
                                }

                            };
                            globalVar.jumpOptions.node().appendChild(button);
                        }
                    }
            }
        }

    </script>

</head>
</html>
